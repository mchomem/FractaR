{
    "contents" : "##################################################################\n#                                                                #\n#    Gerador de fractais baseado nos conjuntos de Mandelbrot.    #\n#                                                                #\n#    Autor:      Misael C. Homem                                 #\n#    Ano:        2015/1                                          #\n#                                                                #\n#    Descrição: Este script r gera iteracoes de fractais         #\n#    baseado na equacao de Mandelbrot e as imprimi em frames     #\n#    coloridos de um gif.                                        #\n#                                                                #\n##################################################################\n\n# External package providing write.gif function\nlibrary(caTools)\n\n# Funcao para gerar a fractal e gravar no disco.\ngenf <- function(x1, y1, x2, y2, max_frames_gif = 30, interval = 10, size = 600, equation, colors) {\n    \n    x1             <- as.numeric(x1)\n    y1             <- as.numeric(y1)\n    x2             <- as.numeric(x2)\n    y2             <- as.numeric(y2)\n    max_frames_gif <- as.numeric(max_frames_gif)\n    interval       <- as.numeric(interval)\n    size           <- as.numeric(size)\n    \n    # checkValues(x1, y1, x2, y2, max_frames_gif, interval, size)\n    \n    # Exibe mensagem no console informando o início do processo.    \n    print( paste(\"[\", as.character(Sys.time()), \"]\", \"Gerando\", max_frames_gif, \"frames de fractal, aguarde...\", sep = \" \") )\n    \n    # Modo randomico com 1 palheta de 9 cores para cores.\n    if(colors == \"random\") {\n        \n        ar <- c()\n        \n        for(n in 1:9) {\n            \n            num <- rnorm(n = 1, mean = 10000000, sd = 10000000)\n            num <- as.integer(num)\n            \n            # Se valor negativo...\n            if(num < 0) {\n                # Muda o sinal\n                num <- abs(num)\n            }\n            \n            # Valor maximo para um inteiro que representa o\n            # maximo valor para um hexa no caso #FFFFFF.\n            if(num > 16777215) {\n                num <- 16777215\n            }\n            \n            # Valor minimo para um inteiro que representa o\n            # minimo valor de um hexa no caso #000000.\n            if(num < 1048575) {\n                num <- 0\n            }\n            \n            # Transforma o inteiro e hexa\n            hex <- as.hexmode(x =  num)\n            \n            # Se o valor igual a zero...\n            if(hex == \"0\") {\n                # Atribui o caracter hexa com seis digitos no formato aceito pela funcao colorRampPalette\n                ar[n] <- \"#000000\"\n            } else {\n                # Formata o valor hexa para o padrao hexa da funcao colorRampPalette\n                ar[n] <- paste(\"#\", hex, sep = \"\")\n            }\n            \n        }\n        \n        # Atribui a paleta de cores randomizadas.\n        jet.colors <- colorRampPalette( c(ar[1], ar[2], ar[3], ar[4], ar[5], ar[6], ar[7], ar[8], ar[9]) )\n        \n    }\n    \n    # Modo fire para cores\n    if(colors == \"fire\") {\n        jet.colors <- colorRampPalette( c(\"#000000\", \"#CC3300\", \"#FF9966\", \"#FFFF66\", \"#FFFFFF\") )\n    }\n    \n    # Modo water para cores\n    if(colors == \"water\") {\n        jet.colors <- colorRampPalette( c(\"#FFFFFF\", \"#000099\", \"#0066FF\", \"#99CCFF\", \"#FFFFFF\") )\n    }\n    \n    # Modo Preto no branco para cores\n    if(colors == \"black_write\") {\n        jet.colors <- colorRampPalette( c(\"#FFFFFF\", \"#000000\") )\n    }\n    \n    # Modo Cosmos para cores\n    if(colors == \"cosmos\") {\n        jet.colors <- colorRampPalette(c(\"#000000\", \"black\", \"#007FFF\", \"cyan\", \"#7FFF7F\", \"yellow\", \"#FF7F00\", \"red\", \"#7F0000\"))\n    }\n    \n    # Obtem um arranjo de numeros complexos\n    C <- complex(real = rep(seq(x1, y1, length.out = size), each = size ), imag = rep(seq(y2, x2, length.out = size), size))\n    \n    # Dimensiona uma matriz de quadrados de numeros complexos\n    C <- matrix(C, size, size)\n    \n    # Inicializa z\n    Z <- 0\n    \n    # Inicializa a saida 3d do array\n    X <- array(0, c(size, size, max_frames_gif))    \n    \n    # Equacao oringal de Mandelbrot\n    if(equation == \"original\") {\n        \n        for (k in 1:max_frames_gif) {\n            \n            Z <- Z ^ 2 + C\n            X[,,k] <- exp(-abs(Z))\n            \n        }\n        \n    }\n    \n    if(equation == \"var_1\") {\n        \n        for (k in 1:max_frames_gif) {\n            \n            Z <- Z ^ 3 + C\n            X[,,k] <- exp(-abs(Z))\n            \n        }\n        \n    }\n    \n    if(equation == \"var_2\") {\n        \n        a <- 4\n        \n        for (k in 1:max_frames_gif) {\n            \n            Z <- Z ^ a + C\n            X[,,k] <- exp(-abs(Z))\n            \n        }\n        \n    }\n    \n    if(equation == \"var_3\") {\n        \n        for (k in 1:max_frames_gif) {\n        \n            Z <- exp(Z) + C\n            X[,,k] <- exp(-abs(Z))\n                \n        }\n        \n    }\n    \n    if(equation == \"var_4\") {\n        \n        for (k in 1:max_frames_gif) {\n            \n            Z <- sinh(Z) + C\n            X[,,k] <- exp(-abs(Z))\n            \n        }\n        \n    }\n    \n    if(equation == \"var_5\") {\n        \n        for (k in 1:max_frames_gif) {\n            \n            Z <- cosh(Z) + C\n            X[,,k] <- exp(-abs(Z))\n            \n        }\n        \n    }\n    \n    if(equation == \"var_6\") {\n        \n        for (k in 1:max_frames_gif) {\n            \n            Z <- tanh(Z) + C\n            X[,,k] <- exp(-abs(Z))\n            \n        }\n        \n    }\n    \n    if(equation == \"var_7\") {\n        \n        for (k in 1:max_frames_gif) {\n            \n            Z <- sin(Z) + C\n            X[,,k] <- exp(-abs(Z))\n            \n        }\n        \n    }\n    \n    if(equation == \"var_8\") {\n        \n        for (k in 1:max_frames_gif) {\n            \n            Z <- cos(Z) + C\n            X[,,k] <- exp(-abs(Z))\n            \n        }\n        \n    }\n    \n    if(equation == \"var_9\") {\n        \n        for (k in 1:max_frames_gif) {\n            \n            Z <- tan(Z) + C\n            X[,,k] <- exp(-abs(Z))\n            \n        }\n        \n    }\n        \n    fileGif <- paste(\"fractal\", \".gif\", sep = \"\")\n    \n    # Escreve o arquivo gif no disco, adicionando cada frame num intervalo determinado.\n    write.gif(X, fileGif, col = jet.colors, delay = interval)\n    \n    # Imprimi no console a finalizacao do processo de geracao do fractal no disco.\n    print( paste(\"[\", as.character(Sys.time()), \"] Arquivo gif gerado no caminho do projeto.\" ) )\n    \n}\n\n# Funcao para fazer a consitencia de valores informados (sem uso)\ncheckValues <- function(vMax_frames_gif, vInterval, vSize) {\n    \n    if(vMax_frames_gif < 0 | vMax_frames_gif > 255 ) {\n        vMax_frames_gif <- 24\n    }\n    \n    if(vInterval < 0 | vInterval > 10) {\n        vInterval <- 10\n    }\n    \n    if(vSize < 100 | vSize > 1200) {\n        vSize <- 600\n    }\n    \n}\n",
    "created" : 1428985499707.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1584549936",
    "id" : "6800D003",
    "lastKnownWriteTime" : 1428985547,
    "path" : "D:/RStudio/workdir/FractaR/Fractal.r",
    "project_path" : "Fractal.r",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}